---
title: 'A semiparametric method to test for correlated evolution in a phylogenetic context'
author:
  - name: Luke J. Harmon
    affiliation: 1
    corresponding: true
    email: lukeh@uidaho.edu
  - name: Liam J. Revell
    affiliation: 2
    corresponding: false
    email: liam.revell@umb.edu
affiliation:
  - code: 1
    address: Department of Biological Sciences, University of Idaho, Moscow, ID, USA
  - code: 2
    address: Department of Biology, University of Massachusetts Boston, Boston, MA, USA
abstract: >
  Phylogenetic comparative methods are a broad suite of approaches for studying trait and species diversification using evolutionary trees. In spite of their substantial growth in sophistication and complexity in recent years, among the most commonly-employed phylogenetic comparative method continues to be a simple measure of the evolutionary correlation between variables, while accounting for the statistical non-independence in our data that arises from common descent. The standard parametric phylogenetic approach for measuring the evolutionary correlation between continuously-valued characters assumes a model called Brownian motion for the evolution of our traits. Here, we introduce a new semiparametric method that relaxes this assumption by testing for the evolutionary correlation between variables based on ranks, and then obtaining a null distribution on the test statistic via random permutation. We show that this approach has reasonable statistical properties: type I error close to the nominal level, and power that's similar to fully parametric methods. We conclude by comparing our new method to related approaches. 
header-includes: |
    \usepackage{fancyhdr}
    \pagestyle{fancy}
    \fancyhead[L]{Harmon \& Revell (2025)}
    \fancyhead[C]{}
    \fancyhead[R]{Semiparametric comparative method}
    \usepackage[singlelinecheck=false]{caption}
    \usepackage{amsmath,mathtools,bm}
output:
  bookdown::pdf_book:
    base_format: rticles::peerj_article
    number_sections: FALSE
bibliography: references.bib
csl: evolution.csl
---

```{r, echo=FALSE, results="hide", message=FALSE}
## load phylogenetics libraries
library(geiger)
library(phytools)

## to parallelize
library(parallel)
library(doParallel)
library(foreach)
```
```{r, echo=FALSE, results="hide", message=FALSE}
picRegression <- function (tree, x, y, method="standard", sigTest="permutation",
  ...) 
{
  ## original version was missing nperm argument so I added it (LR)
  if(hasArg(nperm)) nperm<-list(...)$nperm
  else nperm<-100
  if (!inherits(tree, "phylo")) 
    stop("tree should be object of class \"phylo\".")
  
  if (method %in% c("standard", "sign", "rank") == FALSE) {
    cat("  Invalid model. Setting model=\"standard\"\n\n")
    model <- "standard"
  }
  
  if (sigTest %in% c("analytic", "permutation") == FALSE) {
    cat("  Invalid model. Setting model=\"permutation\"\n\n")
    sigTest <- "permutation"
  }
  
  if((method=="sign" | method=="rank")&sigTest=="analytic") {
    cat("  No analytic p-value method exists for method ", method, ". Setting model=\"permutation\"\n\n")
    sigTest <- "permutation"
  }
  
  if(method=="standard") {
    icx<-ape::pic(x, tree)
    icy<-ape::pic(y, tree)
    
    if(sigTest=="analytic") {
      res<-summary(lm(icy~icx+0))
      testStat<-res$coefficients[1,3]
      pVal<-res$coefficients[1,4]
    }
    if(sigTest=="permutation") {
      dicx<-c(icx, -icx)	
      dicy<-c(icy, -icy)
      res<-summary(lm(dicy~dicx))
      testStat<-res$coefficients[2,3]
      nullDist<-numeric(nperm)
      for(i in 1:nperm) {
        picx<-sample(icx)
        dpicx<-c(picx, -picx)
        res<-summary(lm(dicy~dpicx))
        nullDist[i]<-res$coefficients[2,3]
      }
      
      pValueHigh<-2*(sum(nullDist >= testStat)+1)/(nperm+1)
      pValueLow<-2*(sum(nullDist <= testStat)+1)/(nperm+1)
      
      pVal<-min(pValueHigh, pValueLow)
    }
      
  }
  
  if(method=="sign") {
    icx<-ape::pic(x, tree)
    icy<-ape::pic(y, tree)
    xPos<-icx>0
    yPos<-icy>0
    testStat<-sum(xPos==yPos)
    pValueLow<-2*pbinom(testStat, length(icx), prob=0.5)
    pValueHigh<-2*pbinom(length(icx)-testStat, length(icx), prob=0.5)
    pVal<-min(pValueHigh, pValueLow)
  }
  
  if(method=="rank") {
    icx<-ape::pic(x, tree)
    icy<-ape::pic(y, tree)
    
    dicx<-c(icx, -icx)	
    dicy<-c(icy, -icy)
    
    rx<-rank(dicx, ties.method="average")
    ry<-rank(dicy, ties.method="average")
    res<-summary(lm(ry~rx))
    testStat<-res$coefficients[2,3]
    
    nullDist<-numeric(nperm)
    for(i in 1:nperm) {
      picx<-sample(icx)
      dpicx<-c(picx, -picx)
      prx<-rank(dpicx, ties.method="average")
      res<-summary(lm(ry~prx))
      nullDist[i]<-res$coefficients[2,3]
    }
    
    pValueHigh<-2*(sum(nullDist >= testStat)+1)/(nperm+1)
    pValueLow<-2*(sum(nullDist <= testStat)+1)/(nperm+1)
    
    pVal<-min(pValueHigh, pValueLow)
    
  }
  
  
  obj <- list(testStat=testStat, pVal=pVal)
  class(obj) <- "picRegression"
  obj
}
```
# Introduction

Statistical phylogenetic comparative methods have become an invaluable tool in contemporary evolutionary research [@Felsenstein1985; @Revell2022-book]. This group of methodologies comprises a large and growing set of approaches for studying increasingly sophisticated evolutionary hypotheses of trait and species diversification using phylogenetic trees [reviewed in @Harvey1991; @Nunn2011-book; @OMeara2012; @Harmon2019-book; @Revell2022-book]. Nonetheless, among the most common evolutionary hypothesis studied by researchers using statistical comparative methods is the simple question of whether one trait is correlated with another -- while accounting for the non-independence of the species that that make up our data points due to their shared histories [@Felsenstein1985; reviewed in @Nunn2011-book; @Harmon2019-book; @Revell2022-book].

When measuring and undertaking a hypothesis test of this nature, phylogenetic comparative methods typically assume a particular underlying model of trait evolution, such as the Brownian motion model [@Felsenstein1973a; @Felsenstein1985; @OMeara2006]. Brownian motion (also called a Wiener process) is a continuous-time stochastic diffusion process in which the expected value is constant and the variance increases as a linear function of time multiplied by the Brownian motion rate, typically denoted $\sigma^2$ [@Felsenstein1973a; @Felsenstein2004-book; @OMeara2006; @Harmon2019-book; @Revell2022-book].  In particular, under the phylogenetically independent contrasts algorithm of @Felsenstein1985, both the internal node values in the contrasts algorithm, and the variances of the (non-standardized) contrasts, are calculated assuming a Brownian evolutionary process on the tree [@Felsenstein1985; @Felsenstein2004-book; @Harmon2019-book]. Likewise, under phylogenetic generalized least squares regression [@Grafen1989; @Rohlf2001], we assume that either the data themselves or their residual errors are autocorrelated in a manner consistent with Brownian motion evolution or a closely-related process [e.g., @Pagel1999; @Garland2000; @Rohlf2001; @Revell2010]. Though there are a number of circumstances in which continuously-valued phenotypic traits might genuinely evolve via a Brownian process [e.g., @Lynch1990], violations of the Brownian model are likely be common in real data sets [@Blomberg2003; @Freckleton2006; @Hunt2006; @Estes2007; @Uyeda2011]. Brownian motion has nonetheless persisted as one of the most commonly-used trait evolution models for studying evolutionary correlations, largely due to its simplicity, tractability, and apparent robustness to deviations from model assumptions under some circumstances [e.g., @Garland1993; @Rohlf2001; @Stone2011].

A number of different approaches have been devised to identify violations of Brownian motion in our data while measuring evolutionary correlations, and then to account for these deviations statistically. 

First, we can apply various diagnostic tests for independent contrasts that are sensitive to violations of the Brownian model [e.g., @Garland1992; @Blomberg2003; @Freckleton2006]. For example, if the generative model of the data is Brownian motion, then standardized independent contrasts of @Felsenstein1985 should be independently and identically distributed (i.i.d.). If, on the other hand, standardized contrasts are correlated with their expected variances (that is, the amount of evolutionary branch length that subtends each contrast), this suggests that there may be more or less evolutionary change along long branches of the tree (depending on the sign of the correlation), than would have been expected under a Brownian process [@Garland1992]. We might then attempt various transformations of the branch lengths of the tree so that our contrasts no longer violate this test [@Garland1992].

Another similar and closely-related diagnostic is one that's referred to as the node-height test [@Freckleton2006]. Here, we measure for a relationship between our standardized contrasts and the height above the root of the node over which each contrast was calculated [@Freckleton2006]. Once again, this correlation should be statistically indistinguishable from zero if the Brownian motion model assumptions hold for our data.

Both the measures of @Garland1992 and @Freckleton2006's node-heights test can also be interpreted as measurements of model adequacy. If they fail (that is, if we reject a null hypothesis of no correlation between the standardized contrast and its variance or node height), then this suggests that our underlying assumption of Brownian motion may be invalid [@Pennell2015].

Under circumstances in which Brownian motion has been rejected via a diagnostic test, we might then proceed to consider one or more of a relatively limited set of alternative trait evolution models [e.g., @Pagel1999; @Revell2010]. In particular, we may proceed to fit our correlation assuming a different evolutionary scenario that is nonetheless Gaussian, such as the Ornstein-Uhlenbeck or a speciational trait evolution models [e.g., @Hansen1997; @Martins1997]. Alternatively, we could transform the branches of the phylogenetic tree or the elements of the variance-covariance matrix derived from the tree [@Grafen1989; @Garland1992; @Pagel1999; @Revell2010]. Nevertheless, there is no general solution to the problem of evolutionary model assumption violations, and on occasion there may simply be no way to coax our data set or tree to fit the assumptions of our analysis!

In statistics, nonparametric tests can sometimes provide robustness in cases where models are not known or provide poor fits to data [e.g., @Wasserman2006]. As comparative methods are employed to tackle a wider and wider range of problems, from genomics to cancer biology to evolutionary studies at the broadest scale, there is a growing need for just such robust approaches. Among existing comparative methods, nonparametric methods are already available for the analysis of discrete characters [e.g., @Maddison1990], and for morphometric shape data [@Adams2014]. To date, however, the only non- or semiparametric comparative method designed specifically for measuring the correlation of continuously-valued traits is Ackerly's [-@Ackerly2000] contrast sign test (CST). This test involves comparing the signs (positive or negative) of phylogenetically independent contrasts for two characters [@Ackerly2000]. If the two characters are evolving independently, then the number of pairs of contrasts with the same sign should follow a binomial distribution with probability of success $p=0.5$. The CST provides a robust alternative to fully parametric comparative methods, but is not commonly used. Its primary drawback is that this test can have very low power, in part because it relies only on the contrast signs, and discards all information about their relative magnitudes. 

Here we describe a new semiparametric comparative method, that we call the phylogenetic rank correlation (PRC) test. This test, which is based on the correlation of ranks of independent contrasts on a phylogenetic tree, is robust under several models of trait evolution, and has power comparable to standard independent contrasts and much greater than the CST. We argue that the PRC test thus may provide a robust alternative to fully parametric methods, such as PGLS and independent contrasts, when the Brownian motion evolution model is clearly violated for our data [or their residual error, @Rohlf2001; @Revell2010].

# Description of the Method

The PRC test has a total of six steps (Figure 1), as follows.

1. Calculate standardized independent contrasts [@Felsenstein1985] for two continuously distributed traits, $X$ and $Y$. These contrasts each consist of two numeric values (a contrast for $X$ and a contrast for $Y$), and they should number $\textbf{C}_1$, $\textbf{C}_2$, through $\textbf{C}_m$ for $m$ internal nodes in the tree (Figure 1).

2. Reflect the contrasts, multiplying both the $X$ and $Y$ value of each pair of contrasts in the two traits by $-1$. The data will now include two 'copies' of each $X$, $Y$ pair of contrasts, one with the signs of each contrast reversed. Thus, for example, if contrast $\textbf{C}_1$ consists of the numeric values $[-0.6,1.9]$, we would create an additional contrast in our data set, $\textbf{C}_{m+1}$, that was equal to $[0.6,-1.9]$ (Figure 1), and then proceed to do the same for all $m$ contrasts in our tree.

3. Create ranks independently for the numeric values of the contrasts for each variable, $X$ and $Y$ (Figure 1). In the case of tied values, we should assign the mean rank to all contrast values in the tie. 

4. Calculate the rank correlation test statistic. Here, we use Spearman's rank correlation coefficient [Spearman's $\rho$, @Spearman1904], but we could have also use Kendall's $\tau$ [@Kendall1938]. 

5. Generate a null distribution for the test statistic via randomization of the contrasts. To do this, we must permute the numeric values of the undoubled independent contrasts for one variable, $X$ or $Y$ (it doesn't matter which). Then we reflect the contrasts, create new ranks, and calculate the test statistic. (Note that the ranks of the variable that is not permuted will not change!) We repeat this permutation procedure a large number of times (say, 999 or 9,999), each time recalculating the test statistic ($\rho$ or $\tau$) to obtain a null distribution.

6. Compare the test statistic with the null distribution from permutation to obtain a P-value of the test. We calculate our P-value as $2 \times$ the fraction of permuted test-statistic values (for a two-tailed test) that are equally or more extreme than our measured value of $\rho$ (or $\tau$).

```{r Harmon-fig1, echo=FALSE, fig.width=6, dpi=300, include=TRUE, fig.cap="Illustration of the method of phylogenetic rank contrasts, PRC. First, we compute raw independent contrasts in the standard. For a bifurcation tree with $N$ tips there should be $m=N-1$ such contrasts, in which $m$ is also the number of nodes in the tree. Next, we standardize the contrasts by their expected variance in the typical way following Felsenstein (1985). We duplicate all pairs of contrasts for each of our two variable but swapping the signs (i.e., rotating around $[0,0]$). Next, we convert all contrasts (and their reflections) to ranks. Finally, we calculate the test-statistic, in this case, Spearman's $\\rho$. A P-value for $\\rho$ is obtained via permutation. See main text for more details.", echo=FALSE, out.width = "100%"}
knitr::include_graphics("Harmon-fig1.pdf")
```

Several of these steps might require some additional comment or explanation. 

For step (1.), standardized contrasts are calculated. The calculation of these contrasts, as originally described by @Felsenstein1985, assumes a Brownian motion model of evolution; however, since the standardized contrasts are to be converted into ranks, we maintain that violating this assumption will have a much smaller effect on their subsequent analysis than in a fully parametric approach (see below). In practice, by converting contrasts into ranks we have assumed only that contrasts subtending longer branches of the tree tend to be larger in absolute magnitude. This assumption is compatible with a broad range of evolutionary scenarios, as long as variance among species tends to increase through time [see @Estes2007].

In step (2.), reflecting the contrasts is critical because the direction of any particular contrast is arbitrary. (This can be understood via the thought experiment in which we rotate descendant edges around any node of the tree. Positively-valued contrasts in $X$ or $Y$ will become negative, as well as the converse.) Reflecting contrasts around the origin ensures that our analysis is unchanged by node rotations of the tree. This procedure is likewise conceptually equivalent to forcing our regression line through the point $[0,0]$, which is required when testing for correlations of independent contrasts [@Garland1992b]. We do not have to worry about inflating degrees of freedom by doubling the number of data points because statistical significance is to be determined by permutations. 

Finally, in step (4.), any nonparametric test statistic could be used for this test [see, e.g., @Wasserman2006]. For simplicity, we have chosen to use Spearman's rank correlation (Spearman's $\rho$), which is simply the Pearson product-moment correlation of the ranks of the two variables [@Spearman1904]. Kendall's $\tau$ [@Kendall1938] is another viable option that could be substituted with no other changes to the described methodology. 

We provide a worked example of the calculations involved in this test in Figure 1. Software to carry out this test, written in the R statistical computing language [@RTeam2024], will be made publicly available as part of the popular *geiger* R package [@Harmon2007; @Pennell2014].

# Statistical properties of the method

To explore the statistical properties of our semiparametric evolutionary correlation test, the PRC, we measured type I error and power of the test under a range of circumstances. Then we compared both to the same measures for both non-phylogenetic (i.e., OLS or 'standard' regression) and related phylogenetic comparative methods [independent contrasts, contrasts with a statistical distribution obtained via permutation, and the contrasts sign test of @Ackerly2000].

To measure type I error we started by simulating data for $X$ and $Y$ under Brownian motion evolution and with no evolutionary correlation between the two traits. For this simulation, we first began by generating 400 pure-birth (i.e., Yule) phylogenetic trees containing from $N=10$ to 100 taxa on five taxon intervals (i.e., $N=10$, 15, 20, etc.), an excercise that resulted in a total of $19 \times 400 = 7,600$ simulated trees. These trees were rescaled to have a total height of 1.0, and each of $X$ and $Y$ were simulated (independently, as they are uncorrelated) with a Brownian motion rate of $\sigma^2 = 1.0$. 

Using this set of 7,600 trees and simulated datasets for $X$ and $Y$, we then proceeded to fit a standard (OLS) regression ("Standard"), a contrasts regression ("IC"), a contrasts regression but in which a P-value for hypothesis testing was obtained via random permutation ("IC Perm"), the contrasts sign test ("CST"), and our phylogenetic rank correlation ("PRC"). We decided to include a permutation test based on phylogenetically independent contrasts to ensure that our measured type I error and power for the PRC were due to the use of a rank correlation, rather than for having substituted a permutation distribution for the parametric distribution typically used in phylogenetic correlation with independent contrasts. For each analysis we computed a P-value, and then we estimated the type I error rate as the fraction of P-values from each set of simulation conditions and analysis with values equal or smaller than 5\%. 

Results from this analysis are given in Figure 2a. Consistent with expectations [e.g., @Revell2010], we found high type I error of OLS regression for phylogenetic data simulated under Brownian motion (Figure 2a), at a rate that increased with increasing numbers of taxa, $N$ (Figure 2a). By contrast, when the assumption of Brownian motion evolution held true, all phylogenetic analyses had type I error rates close to the nominal level of $\alpha = 0.05$ (Figure 2a).

We next proceeded to simulated uncorrelated data for $X$ and $Y$, but this time under an Ornstein-Uhlenbeck, rather than Browian, process. The Ornstein-Uhlenbeck process is a stochastic process similar to Brownian motion, but in which there exists a tendency to revert towards some central value of the trait [@Hansen1997; @Butler2004]. (As such Ornstein-Uhlenbeck is sometimes referred to as Brownian motion with a 'rubber-band,' in which we can imagine an elastic rubber bands that tends to pull the stochastic process towards its tether-point.) The strength of this tendency is determined by the model parameter $\alpha$ (not to be confused with our nominal type I error rate, also denoted as $\alpha$). Higher values of $\alpha$ correspond to a greater tendency to revert towards the central value. The parameter $\alpha$ can also be understood in terms of "phylogenetic half-life" [@Hansen2008], $\ln(2)/\alpha$, which measures have the time a trait is expected to evolve from its ancestral value to the optimum of the Ornstein-Uhlenbeck process. Conversely, a value of $\alpha = 0$ (and consequently a phylogenetic half-life of $\ln(2)/\alpha = \infty$) corresponds to Brownian motion evolutionary change. 

Using only the set of 400 simulated trees with $N=50$ from our prior analysis, we simulated data for $X$ and $Y$ under an Ornstein-Uhlenbeck model with values of $\alpha = 0.1$, 0.2, 0.5, 1, 2, 5, and 10. This resulted in a total of $7 \times 400 = 2,800$ simulated datasets. We then repeated the same non-phylogenetic and phylogenetic correlation analyses as were described in the previous section.

Results for this test are shown in Figure 2b. In general, we found that type I error of the non-phylogenetic (i.e., standard) regression was highest for low $\alpha$ and decreased with increasing $\alpha$ (Figure 2b). This is fairly unsurprising because low $\alpha$ corresponds closely to Brownian motion in which a standard correlation is unreliable; while (by contrast) very high $\alpha$ tends to reduce the autocorrelation of species data which, in the limit as $\alpha \rightarrow \infty$, will lose all phylogenetic autocorrelation altogether and thus satisfy the assumptions of standard OLS. Conversely, type I error of all phylogenetic methods was close to the nominal level of $\alpha = 0.05$ for the lowest values of (Ornstein-Uhlenbeck) $\alpha$, but increased for higher $\alpha$. This increase, however, was smallest for the CST and PRC (of this article), and highest for standard independent contrasts and permutation-based contrasts regression (Figure 2b).

Taken together, these results indicate that our semiparametric contrasts rank correlation method (PRC) has type I error under Brownian motion that is virtually identical to existing parametric and non-parametric phylogenetic evolutionary correlation tests (Figure 2a). Our results also show, however, that the phylogenetic rank correlation test can have much lower type I error than parametric methods when the strict assumption of Brownian motion evolution is violated by our data (Figure 2b).

```{r, echo=FALSE, eval=FALSE}
## type I error analysis

## set seed
set.seed(99)

## set up cluster
ncores<-max(10,detectCores())
mc<-makeCluster(ncores,type="PSOCK")
registerDoParallel(cl=mc)

## first simulate under uncorrelated Brownian motion
## for two traits

## this is a test of type I error under the null 
## for standard contrasts

## number of taxa
ntaxa<-seq(10,100,by=5)

## number of simulations
ns<-400

## simulate trees (we'll re-utilize these)
sim_trees<-foreach(i=1:length(ntaxa))%dopar%{
  phytools::pbtree(n=ntaxa[i],scale=1,nsim=ns)
}

## simulate data
sim_bm<-foreach(i=1:length(ntaxa))%dopar%{
  lapply(sim_trees[[i]],phytools::fastBM,nsim=2)
}

## create matrices for results
pStandard<-pContrasts<-pContrastsPerm<-pRank<-
  pSign<-tContrasts<-tContrastsPerm<-tStandard<-
  tRank<-tSign<-matrix(nrow=ns, ncol=length(ntaxa),
    dimnames=list(1:ns,ntaxa))

## iterate over ntaxa
for(i in 1:length(ntaxa)){
  r0<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[i]][[j]]
    x<-sim_bm[[i]][[j]][,1]
    y<-sim_bm[[i]][[j]][,2]
    summary(lm(y~x))
  }
  r1<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[i]][[j]]
    x<-sim_bm[[i]][[j]][,1]
    y<-sim_bm[[i]][[j]][,2]
    picRegression(t, x, y, method="standard", 
      sigTest="analytic")
  }
  r2<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[i]][[j]]
    x<-sim_bm[[i]][[j]][,1]
    y<-sim_bm[[i]][[j]][,2]
    picRegression(t, x, y, method="standard", 
      sigTest="permutation")
  }
  r3<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[i]][[j]]
    x<-sim_bm[[i]][[j]][,1]
    y<-sim_bm[[i]][[j]][,2]
    picRegression(t, x, y, method="sign", 
      sigTest="permutation")
  }
  r4<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[i]][[j]]
    x<-sim_bm[[i]][[j]][,1]
    y<-sim_bm[[i]][[j]][,2]
    picRegression(t, x, y, method="rank", 
      sigTest="permutation")
  }
  ## populate matrices with test statistics
  tStandard[,i]<-sapply(r0,function(x) x$coefficients[2,4])
  tContrasts[,i]<-sapply(r1,function(x) x$testStat)
  tContrastsPerm[,i]<-sapply(r2,function(x) x$testStat)
  tSign[,i]<-sapply(r3,function(x) x$testStat)
  tRank[,i]<-sapply(r4,function(x) x$testStat)
  ## populate matrices with P-values
  pStandard[,i]<-sapply(r0,function(x) x$coefficients[2,4])
  pContrasts[,i]<-sapply(r1,function(x) x$pVal)
  pContrastsPerm[,i]<-sapply(r2,function(x) x$pVal)
  pSign[,i]<-sapply(r3,function(x) x$pVal)
  pRank[,i]<-sapply(r4,function(x) x$pVal)
  
  cat(paste("Done with N = ",ntaxa[i]," ...\n",sep=""))
}

countSignif<-function(p) {
  sum(p<0.05)/length(p)
}
t1Standard<-apply(pStandard, 2, countSignif)
t1Contrasts<-apply(pContrasts, 2, countSignif)
t1ContrastsPerm<-apply(pContrastsPerm, 2, countSignif)
t1Sign<-apply(pSign, 2, countSignif)
t1Rank<-apply(pRank, 2, countSignif)

## second simulate under uncorrelated Ornstein-Uhlenbeck
## for two traits with varied alpha levels

## this is a test of type I error under the null 
## for standard contrasts

## levels of alpha
alpha<-c(0.1,0.2,0.5,1,2,5,10)

## simulate data
foo<-function(phy,alpha){
  ou<-geiger:::rescale.phylo(phy,model="OU",alpha=alpha)
  phytools::fastBM(ou,nsim=2)
}

nn<-which(ntaxa==50)

sim_ou<-foreach(i=1:length(alpha))%dopar%{
  lapply(sim_trees[[nn]],foo,alpha=alpha[i])
}

## create matrices for results
pStandard<-pContrasts<-pContrastsPerm<-pRank<-
  pSign<-tContrasts<-tContrastsPerm<-tStandard<-
  tRank<-tSign<-matrix(nrow=ns, ncol=length(alpha),
    dimnames=list(1:ns,alpha))

## iterate over alpha
for(i in 1:length(alpha)){
  r0<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[nn]][[j]]
    x<-sim_ou[[i]][[j]][,1]
    y<-sim_ou[[i]][[j]][,2]
    summary(lm(y~x))
  }
  r1<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[nn]][[j]]
    x<-sim_ou[[i]][[j]][,1]
    y<-sim_ou[[i]][[j]][,2]
    picRegression(t, x, y, method="standard", 
      sigTest="analytic")
  }
  r2<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[nn]][[j]]
    x<-sim_ou[[i]][[j]][,1]
    y<-sim_ou[[i]][[j]][,2]
    picRegression(t, x, y, method="standard", 
      sigTest="permutation")
  }
  r3<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[nn]][[j]]
    x<-sim_ou[[i]][[j]][,1]
    y<-sim_ou[[i]][[j]][,2]
    picRegression(t, x, y, method="sign", 
      sigTest="permutation")
  }
  r4<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[nn]][[j]]
    x<-sim_ou[[i]][[j]][,1]
    y<-sim_ou[[i]][[j]][,2]
    picRegression(t, x, y, method="rank", 
      sigTest="permutation")
  }
  ## populate matrices with test statistics
  tStandard[,i]<-sapply(r0,function(x) x$coefficients[2,4])
  tContrasts[,i]<-sapply(r1,function(x) x$testStat)
  tContrastsPerm[,i]<-sapply(r2,function(x) x$testStat)
  tSign[,i]<-sapply(r3,function(x) x$testStat)
  tRank[,i]<-sapply(r4,function(x) x$testStat)
  ## populate matrices with P-values
  pStandard[,i]<-sapply(r0,function(x) x$coefficients[2,4])
  pContrasts[,i]<-sapply(r1,function(x) x$pVal)
  pContrastsPerm[,i]<-sapply(r2,function(x) x$pVal)
  pSign[,i]<-sapply(r3,function(x) x$pVal)
  pRank[,i]<-sapply(r4,function(x) x$pVal)
  
  cat(paste("Done with alpha = ",alpha[i]," ...\n",sep=""))
}

countSignif<-function(p) {
  sum(p<0.05)/length(p)
}
t2Standard<-apply(pStandard, 2, countSignif)
t2Contrasts<-apply(pContrasts, 2, countSignif)
t2ContrastsPerm<-apply(pContrastsPerm, 2, countSignif)
t2Sign<-apply(pSign, 2, countSignif)
t2Rank<-apply(pRank, 2, countSignif)

stopCluster(mc)

## save Rdata
save(sim_trees,ntaxa,ns,
  t1Standard,t1Contrasts,t1ContrastsPerm,t1Rank,t1Sign,
  alpha,
  t2Standard,t2Contrasts,t2ContrastsPerm,t2Rank,t2Sign,
  file="typeI-error-analysis.Rdata")
```
```{r Harmon-fig2, echo=FALSE, fig.width=11, fig.height=5.5, dpi=300, fig.cap="Results of the analysis of type I error. (a) Type I error of both a standard (non-phylogenetic) correlation, and various phylogenetic correlations, when data for \\emph{X} and \\emph{Y} were simulated under a Brownian motion model, for various total number of taxa, \\emph{N}. (b) Type I error for standard and phylogenetic correlation tests when data were simulated under an Ornstein-Uhlenbeck process, for various values of $\\alpha$.", out.width = "100%"}
## load Rdata
load("typeI-error-analysis.Rdata")

## subdivide plotting area
par(mfrow=c(1,2))

## create plot panel (a)
x<-ntaxa
plot(x, t1Standard,  type="l", ylim=c(0, 0.6), lwd=2, 
  xlab="number of taxa", ylab="type I error rate",
  las=1,bty="n")
lines(c(1, 100), c(0.05, 0.05), col="red")
lines(x, t1Contrasts, lwd=2, col="black", lty=2)
lines(x, t1ContrastsPerm, lwd=2, col="black", lty=3)
lines(x, t1Rank, lwd=2, col="grey")
lines(x, t1Sign, lwd=2, col="grey", lty=2)
grid()
legend("topleft", lwd=2, col=c("black", "black", "black", 
  "grey", "grey"), legend=c("Standard", "IC", "IC Perm", 
    "CST", "PRC"), lty=c(1, 2,3, 1, 2), bg="white")
mtext("a) type I error rate under Brownian motion",
  line=2,adj=0)

## create plot panel (b)
x<-alpha
plot(x, t2Standard,  type="l", ylim=c(0, 0.6), lwd=2, 
  xlab=expression(paste(alpha," of OU model")), 
  ylab="type I error rate",
  las=1,bty="n",log="x")
lines(c(0.001, 11), c(0.05, 0.05), col="red")
lines(x, t2Contrasts, lwd=2, col="black", lty=2)
lines(x, t2ContrastsPerm, lwd=2, col="black", lty=3)
lines(x, t2Rank, lwd=2, col="grey")
lines(x, t2Sign, lwd=2, col="grey", lty=2)
grid()
legend("topleft", lwd=2, col=c("black", "black", "black", 
  "grey", "grey"), legend=c("Standard", "IC", "IC Perm", 
    "CST", "PRC"), lty=c(1, 2,3, 1, 2), bg="white")
mtext("b) type I error rate under Ornstein-Uhlenbeck",
  line=2,adj=0)
```

In addition to measuring type I error, we also wanted to test the power of the PRC method to detect a statistically significant correlation where one exists. To this end, we simulated data for $X$ and $Y$ using exactly the same simulation conditions as for Figure 2, described above, but in which our data were simulated with an evolutionary correlation between the traits of $r = 0.5$, instead of in an uncorrelated fashion. Power for each simulation condition and method was scored as the fraction of P-values than were equal to or fell below 5\%. The results for this analysis are given in Figure 3.

When $X$ and $Y$ were simulated under Brownian motion, we found that standard contrasts (IC) and contrasts with a statistical test via permutation (IC Perm) had the highest power; however, these methods were followed closely by our semiparametric PRC (Figure 3a). Ackerly's [-@Ackerly2000] CST method had the lowest power of all methods (Figure 3a). When our correlated data for $X$ and $Y$ were simulated under Ornstein-Uhlenbeck a similar pattern repeats in which standard contrasts (IC), a permutation test using contrasts (IC Perm), standard (non-phylogenetic) correlation, and our phylogenetic rank correlation (PRC) have the highest power -- much higher than the power of the CST by Ackerly (2000; Figure 3b).

```{r, echo=FALSE}
## clean up workspace for next analysis
rm(list=ls()[-which(ls()%in%c("sim_trees","picRegression","ns","ntaxa"))])
```
```{r, echo=FALSE, eval=FALSE}
## power analysis

## set seed
set.seed(99)

## set up cluster
ncores<-max(10,detectCores())
mc<-makeCluster(ncores,type="PSOCK")
registerDoParallel(cl=mc)

## third simulate correlated Brownian motion
## for two traits

## this is a test of power

## number of taxa
ntaxa<-seq(10,100,by=5)

## simulate data
cor_mat<-matrix(c(1,0.5,0.5,1),2,2)
sim_corbm<-foreach(i=1:length(ntaxa))%dopar%{
  lapply(sim_trees[[i]],phytools::sim.corrs,vcv=cor_mat)
}

## create matrices for results
pStandard<-pContrasts<-pContrastsPerm<-pRank<-
  pSign<-tContrasts<-tContrastsPerm<-tStandard<-
  tRank<-tSign<-matrix(nrow=ns, ncol=length(ntaxa),
    dimnames=list(1:ns,ntaxa))

## iterate over ntaxa
for(i in 1:length(ntaxa)){
  r0<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[i]][[j]]
    x<-sim_corbm[[i]][[j]][,1]
    y<-sim_corbm[[i]][[j]][,2]
    summary(lm(y~x))
  }
  r1<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[i]][[j]]
    x<-sim_corbm[[i]][[j]][,1]
    y<-sim_corbm[[i]][[j]][,2]
    picRegression(t, x, y, method="standard", 
      sigTest="analytic")
  }
  r2<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[i]][[j]]
    x<-sim_corbm[[i]][[j]][,1]
    y<-sim_corbm[[i]][[j]][,2]
    picRegression(t, x, y, method="standard", 
      sigTest="permutation")
  }
  r3<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[i]][[j]]
    x<-sim_corbm[[i]][[j]][,1]
    y<-sim_corbm[[i]][[j]][,2]
    picRegression(t, x, y, method="sign", 
      sigTest="permutation")
  }
  r4<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[i]][[j]]
    x<-sim_corbm[[i]][[j]][,1]
    y<-sim_corbm[[i]][[j]][,2]
    picRegression(t, x, y, method="rank", 
      sigTest="permutation")
  }
  ## populate matrices with test statistics
  tStandard[,i]<-sapply(r0,function(x) x$coefficients[2,4])
  tContrasts[,i]<-sapply(r1,function(x) x$testStat)
  tContrastsPerm[,i]<-sapply(r2,function(x) x$testStat)
  tSign[,i]<-sapply(r3,function(x) x$testStat)
  tRank[,i]<-sapply(r4,function(x) x$testStat)
  ## populate matrices with P-values
  pStandard[,i]<-sapply(r0,function(x) x$coefficients[2,4])
  pContrasts[,i]<-sapply(r1,function(x) x$pVal)
  pContrastsPerm[,i]<-sapply(r2,function(x) x$pVal)
  pSign[,i]<-sapply(r3,function(x) x$pVal)
  pRank[,i]<-sapply(r4,function(x) x$pVal)
  
  cat(paste("Done with N = ",ntaxa[i]," ...\n",sep=""))
}

countSignif<-function(p) {
  sum(p<0.05)/length(p)
}
t3Standard<-apply(pStandard, 2, countSignif)
t3Contrasts<-apply(pContrasts, 2, countSignif)
t3ContrastsPerm<-apply(pContrastsPerm, 2, countSignif)
t3Sign<-apply(pSign, 2, countSignif)
t3Rank<-apply(pRank, 2, countSignif)

## third simulate correlated evolution on OU tree
## for two traits

## this is a test of power

## levels of alpha
alpha<-c(0.1,0.2,0.5,1,2,5,10)

## simulate data
cor_mat<-matrix(c(1,0.5,0.5,1),2,2)

foo<-function(phy,alpha){
  ou<-geiger:::rescale.phylo(phy,model="OU",alpha=alpha)
  phytools::sim.corrs(ou,vcv=cor_mat)
}

nn<-which(ntaxa==50)

sim_corou<-foreach(i=1:length(alpha))%dopar%{
  lapply(sim_trees[[nn]],foo,alpha=alpha[i])
}

## create matrices for results
pStandard<-pContrasts<-pContrastsPerm<-pRank<-
  pSign<-tContrasts<-tContrastsPerm<-tStandard<-
  tRank<-tSign<-matrix(nrow=ns, ncol=length(alpha),
    dimnames=list(1:ns,alpha))

## iterate over alpha
for(i in 1:length(alpha)){
  r0<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[nn]][[j]]
    x<-sim_corou[[i]][[j]][,1]
    y<-sim_corou[[i]][[j]][,2]
    summary(lm(y~x))
  }
  r1<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[nn]][[j]]
    x<-sim_corou[[i]][[j]][,1]
    y<-sim_corou[[i]][[j]][,2]
    picRegression(t, x, y, method="standard", 
      sigTest="analytic")
  }
  r2<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[nn]][[j]]
    x<-sim_corou[[i]][[j]][,1]
    y<-sim_corou[[i]][[j]][,2]
    picRegression(t, x, y, method="standard", 
      sigTest="permutation")
  }
  r3<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[nn]][[j]]
    x<-sim_corou[[i]][[j]][,1]
    y<-sim_corou[[i]][[j]][,2]
    picRegression(t, x, y, method="sign", 
      sigTest="permutation")
  }
  r4<-foreach(j=1:ns)%dopar%{
    t<-sim_trees[[nn]][[j]]
    x<-sim_corou[[i]][[j]][,1]
    y<-sim_corou[[i]][[j]][,2]
    picRegression(t, x, y, method="rank", 
      sigTest="permutation")
  }
  ## populate matrices with test statistics
  tStandard[,i]<-sapply(r0,function(x) x$coefficients[2,4])
  tContrasts[,i]<-sapply(r1,function(x) x$testStat)
  tContrastsPerm[,i]<-sapply(r2,function(x) x$testStat)
  tSign[,i]<-sapply(r3,function(x) x$testStat)
  tRank[,i]<-sapply(r4,function(x) x$testStat)
  ## populate matrices with P-values
  pStandard[,i]<-sapply(r0,function(x) x$coefficients[2,4])
  pContrasts[,i]<-sapply(r1,function(x) x$pVal)
  pContrastsPerm[,i]<-sapply(r2,function(x) x$pVal)
  pSign[,i]<-sapply(r3,function(x) x$pVal)
  pRank[,i]<-sapply(r4,function(x) x$pVal)
  
  cat(paste("Done with alpha = ",alpha[i]," ...\n",sep=""))
}

countSignif<-function(p) {
  sum(p<0.05)/length(p)
}
t4Standard<-apply(pStandard, 2, countSignif)
t4Contrasts<-apply(pContrasts, 2, countSignif)
t4ContrastsPerm<-apply(pContrastsPerm, 2, countSignif)
t4Sign<-apply(pSign, 2, countSignif)
t4Rank<-apply(pRank, 2, countSignif)

## stop cluster
stopCluster(mc)

## save Rdata
save(sim_trees,ntaxa,ns,
  t3Standard,t3Contrasts,t3ContrastsPerm,t3Rank,t3Sign,
  alpha,
  t4Standard,t4Contrasts,t4ContrastsPerm,t4Rank,t4Sign,
  file="power-analysis.Rdata")
```
```{r Harmon-fig3, echo=FALSE, fig.width=11, fig.height=5.5, dpi=300, fig.cap="Results of the analysis of power for a true underlying evolution correlation between \\emph{X} and \\emph{Y} of $r = 0.5$. (a) Power of both a standard (non-phylogenetic) correlation, and various phylogenetic correlations, when data for \\emph{X} and \\emph{Y} were simulated under a Brownian motion model, for various total number of taxa, \\emph{N}. (b) Power of standard and phylogenetic correlation tests when data were simulated under an Ornstein-Uhlenbeck process, for various values of $\\alpha$.", out.width = "100%"}
## load Rdata
load("power-analysis.Rdata")

## subdivide plotting area
par(mfrow=c(1,2))

## create panel (a) of plot
x<-ntaxa
plot(x, t3Standard,  type="l", ylim=c(0, 1), lwd=2, 
  xlab="number of taxa", ylab="power to reject null",
  las=1,bty="n")
lines(x, t3Contrasts, lwd=2, col="black", lty=2)
lines(x, t3ContrastsPerm, lwd=2, col="black", lty=3)
lines(x, t3Rank, lwd=2, col="grey")
lines(x, t3Sign, lwd=2, col="grey", lty=2)
grid()
legend("bottomright", lwd=2, col=c("black", "black", "black", 
  "grey", "grey"), legend=c("Standard", "IC", "IC Perm", 
    "CST", "PRC"), lty=c(1, 2,3, 1, 2), bg="white")
mtext("a) power under Brownian motion with r = 0.5",
  line=2,adj=0)

## create panel (b) of plot
x<-alpha
plot(x, t4Standard,  type="l", ylim=c(0, 1), lwd=2, 
  xlab=expression(paste(alpha," of OU model")), 
  ylab="power to reject null",
  las=1,bty="n",log="x")
lines(x, t4Contrasts, lwd=2, col="black", lty=2)
lines(x, t4ContrastsPerm, lwd=2, col="black", lty=3)
lines(x, t4Rank, lwd=2, col="grey")
lines(x, t4Sign, lwd=2, col="grey", lty=2)
grid()

legend("bottomright", lwd=2, col=c("black", "black", "black", 
  "grey", "grey"), legend=c("Standard", "IC", "IC Perm", 
    "CST", "PRC"), lty=c(1, 2,3, 1, 2), bg="white")

mtext("b) power under Ornstein-Uhlenbeck with r = 0.5",
  line=2,adj=0)
```

# Discussion

Phylogenetic comparative methods have become an indispensable tool of evolutionary research [reviewed in @Harmon2019-book; @Revell2022-book], and are increasingly employed across a wide variety of different research fields, from community ecology, to cancer biology, to infectious disease epidemiology [e.g., @Peterson2021; @Gao2022; @Magalis2024]. Even as they grow in complexity and sophistication, a simple test of the evolutionary correlation of two variables (while accounting for statistical non-independence arising from common descent) remains among the most popular phylogenetic comparative analyses. Typical methods for measuring the evolutionary correlation between traits, however, rely on an assumption of Brownian motion evolution of the variables or their residual error [@Felsenstein1985; @Garland1992b].

In this contribution, we introduce a new semiparametric phylogenetic rank correlation (PRC) test that seeks to relax this assumption. We have characterized this method as “semiparametric” because it is not truly distribution-free. Indeed, the method begins via the calculation of standardized independent contrasts (see Figure 1). Standardization is undertaken by dividing each raw contrast by its expected variance, a step that implicitly assumes our traits have evolved under a Brownian process [@Felsenstein1985]! Nonetheless, we assert, and the results of our simulation analyses show, that by converting these contrasts to ranks, the PRC method substantially lessens the effects of violations of this assumption for testing correlations between characters (Figures 2, 3). This is probably because by transforming the standardized contrasts into ranks, our assumption of Brownian evolution effectively changes into the much weaker assumption that longer branches of the tree should contain more evolution of the trait (on average) than do shorter branches. Though this is likely to be true across a much broader swathe of evolutionary processes than is strict Brownian motion evolution, it's not difficult to envision circumstances in which this assumption (too) is violated. Indeed, we would predict that strong heterogeneity in the rate of evolution [e.g., @OMeara2006] will lead to elevated type I error of the PRC, just as it would to all of the other phylogenetic methods explored in this article. In a case were substantial heterogeneity of the rate of evolution is thought to exist, we would recommend a method designed to explicitly account for this variation [e.g., Revell2009; Caetano2018].

# Conclusions 

Phylogenetic comparative methods are often employed to measure the correlation between continuously-valued species characteristics. Here, we provide a robust semiparametric correlation test that has fewer assumptions than do traditional approaches, but higher power than competing non- or semiparametric methods [e.g., @Ackerly2000]. We propose that this method be considered under condition in which the statistical significance of an evolutionary correlation between traits is of interest, but where the satisfaction of model assumptions cannot be assured.

# Code and data availability

All analyses of this article were undertaken in R [@RTeam2024], using the contributed R packages *ape* [@Paradis2019], *geiger* [@Pennell2014], and *phytools* [@Revell2024]. Parallelization of simulations was accomplished using the *foreach* package [@Microsoft2022-b]. Manuscript drafts of the article were written in Rmarkdown [@Xie2018; @Xie2022; @Allaire2023], and developed with the help of both *bookdown* [@Xie2016; @Xie2023] and the posit Rstudio IDE [@Rstudio2020]. All data and markdown code necessary to exactly rebuild the submitted version of this article (including its analyses and figures) can be found at [https://github.com/liamrevell/Revell-and-Harmon.NonParametricPCM](https://github.com/liamrevell/Revell-and-Harmon.NonParametricPCM).

# Acknowledgments

We thank J. J. Kolbe, J. B. Losos, D. Schluter, R. E. Glor, B. Banbury, T. Hagey, C. Brock, and H. Alamillo for providing helpful feedback on this paper.

# Literature Cited